Our infrastructure simplifies both the configuration of the authentication service and the subsequent configuration of user permissions “Authentication”.
Start by installing the NuGet “Microsoft.AspNetCore.Authentication.JwtBearer 8 package.Max”. 
Copy the “Authentication” folder of our infrastructure to the main root of the project and edit the file “Program.cs” as follows:

using [Project name].UserAuthentication;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.

builder.Services.AddControllersWithViews();

//cookie based
Authentication.AddAuthentication(builder);

/jwt bearer based 
BearerToken.AddAuthentication(builder);

var app = builder.Build();

// Configure the HTTP request pipeline.

if (!app.Environment.IsDevelopment())

{

    app.UseExceptionHandler("/Home/Error");
    
    app.UseHsts();   
    
}
app.UseHttpsRedirection();

app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();

app.MapControllerRoute(

    name: "default",
    
    pattern: "{controller=Home}/{action=Index}/{id?}");
    
app.Run();

Model description

The infrastructure is based on the four classes "abstractAuthentication.cs", "Authentication.cs", "BearerToken.cs" and "LocalToken.cs".

The main one, Authentication.cs, exposes convenient static methods for configuring the authentication service and login and logout processes.

AddAuthentication configures the authentication service (see Program.cs) or the characteristics of the authentication cookie and its lifecycle.

LoginPath, LogoutPath, AccessDeniedPath, if specified, must actually be present.

The implementation does not require further investigation with the exception of the “CheckBearerTokenExpiration” flag. When its value is “true” the authentication service will also verify, if it exists among the claims, the validity date of the Bearer Token and in case of a known expiration it will force the SignOut of the authentication cookie.

The Bearer Token is typically generated by a microservices web server, including user authentication and authorization.

The authentication process uses the SignIn overloaded method which requires a list of Claims and the user identifier in case of local authentication or a Bearer Token in case of cross domain authentication. 

The BearerToken class provides the following methods:

- public static void AddAuthentication(WebApplicationBuilder builder)
- public static string ClaimValue(JwtSecurityToken token, string ClaimType)
- public static List<Claim> Claims(JwtSecurityToken token, bool includeToken = true)
- public static List<Claim> Claims(string token, bool includeToken = true)
- public static bool TokenExist(ClaimsPrincipal User)
- public static string Token(List<Claim> Claims, HttpContext context,int UserId)
- public static string Token(List<Claim> Claims,
                             HttpContext context,
                             string Issuer, 
                             string Audience, 
                             int? ExpiresMinutes,
                             string Key256,
                             int UserId)
- public static string Token(ClaimsPrincipal User)
- public static JwtSecurityToken Token(string StringToken)
- public static JwtSecurityToken Token(HttpRequest Request)
- public static bool Expired(string token)
- public static bool Expired(JwtSecurityToken token)  

The class simplifies the handling of a Bearer-type token released by an authentication microservice.

AddAuthentication method configure and register the bearer token-based authentication service.

The Claims property returns the list of claims registered in the token payload section by adding a new one with the original token.

This solution is much more convenient and secure and allows, among other things, to link the lifecycle of the authentication cookie to that of the Token and the opposite.

The TokenExist property checks for the existence of a claim with the value key “AuthenticationScheme”.

The Token string property returns the string stored in the Token claim value, i.e., the Token as received by the authentication micro service.

Finally, the Expired Boolean property compares the Token's end-of-validity date with the web server's current end-of-validity date.

The final LocalToken class provides an interface for serializing and deserializing claims associated with a user in the case of local authentication architectures.

Example of creating a session cookie obtained from the bearer token.

Context:

An authentication service finds a user's credentials and generates a bearer token:

int userid = 1;

List<Claim> claims = new List<Claim>();

claims.Add(new Claim("admin", "customers"));

claims.Add(new Claim("admin", "suppliers"));
                        
string token = BearerToken.Token(claims, HttpContext, userid);

The token is returned to the requesting service which generates and assigns the session cookie to the user's browser:

UserAuthentication.Authentication.SignIn(token, HttpContext, false);

Example of generating session cookie without bearer token.

int userid = 1;

List<Claim> claims = new List<Claim>();

claims.Add(new Claim("admin", "customers"));

claims.Add(new Claim("admin", "suppliers"));

UserAuthentication.Authentication.SignIn(claims,HttpContext,false,1);









