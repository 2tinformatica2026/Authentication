Our infrastructure simplifies both the configuration of the authentication service and the subsequent configuration of user permissions “Authentication”.
Start by installing the NuGet “Microsoft.AspNetCore.Authentication.JwtBearer 8 package.Max”. 
Copy the “Authentication” folder of our infrastructure to the main root of the project and edit the file “Program.cs” as follows:

using [Project name].UserAuthentication;

using [Project name].UserLocalization;

var builder = WebApplication.CreateBuilder(args);

Localization Culture = new Localization();

Culture.AddLocalization(builder, "Resources", Localization.LocationExpanderFormat.MvcViewSuffix);

// Add services to the container.

builder.Services.AddControllersWithViews();

Authentication.AddAuthentication(builder,30, "/Authentication/Login", "/Home/Index", "/Home/Index");

var app = builder.Build();

Culture.UseRequestLocalization(app);

// Configure the HTTP request pipeline.

if (!app.Environment.IsDevelopment())

{

    app.UseExceptionHandler("/Home/Error");
    
    app.UseHsts();   
    
}
app.UseHttpsRedirection();

app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();

app.MapControllerRoute(

    name: "default",
    
    pattern: "{controller=Home}/{action=Index}/{id?}");
    
app.Run();

Model description

The infrastructure is based on the three classes "Authentication.cs", "BearerToken.cs" and "LocalToken.cs".

The main one, Authentication.cs, exposes convenient static methods for configuring the authentication service and login and logout processes.

AddAuthentication configures the authentication service (see Program.cs) or the characteristics of the authentication cookie and its lifecycle.

LoginPath, LogoutPath, AccessDeniedPath, if specified, must actually be present.

The implementation does not require further investigation with the exception of the “CheckBearerTokenExpiration” flag. When its value is “true” the authentication service will also verify, if it exists among the claims, the validity date of the Bearer Token and in case of a known expiration it will force the SignOut of the authentication cookie.

The Bearer Token is typically generated by a microservices web server, including user authentication and authorization.

The authentication process uses the SignIn overloaded method which requires a list of Claims and the user identifier in case of local authentication or a Bearer Token in case of cross domain authentication. 

The BearerToken class provides the following methods:

- public static string ClaimName { get { return JwtBearerDefaults.AuthenticationScheme;} }
- public static bool TokenExist(ClaimsPrincipal User)
- public static string Token(ClaimsPrincipal User)
- public static bool Expired(ClaimsPrincipal User)

The class simplifies the handling of a Bearer-type token released by an authentication microservice.

The Claims property returns the list of claims registered in the token payload section by adding a new one with the original token.

This solution is much more convenient and secure and allows, among other things, to link the lifecycle of the authentication cookie to that of the Token and the opposite.

The TokenExist property checks for the existence of a claim with the value key “ClaimName”.

The Token string property returns the string stored in the Token claim value, i.e., the Token as received by the authentication micro service.

Finally, the Expired Boolean property compares the Token's end-of-validity date with the web server's current end-of-validity date.

The final LocalToken class provides an interface for serializing and deserializing claims associated with a user in the case of local authentication architectures.

